## 레거시 시스템 분석

### 비즈니스 로직

1. SFTP 전문 수신하여 가맹점 데이터 저장 처리 
	1. `가맹점번호` 기준 KB 가맹점 DB 조회
		1. 기존 정보 있는 경우, 정보 변경
		2. 기존 정보 없는 경우, 신규 등록
	2. `KB_MERCHANT` 테이블 DB 저장
	3. `KB_MERCHANT_HISTORY` 테이블 DB 저장
2. 가맹점 주소 기준 `KAS` 좌표 정보 조회하여 데이터 저장 처 
3. 가맹점 저장 처리 후 `LBMS` 가맹점 등록 요청 처리

#### 1차 성능 개선
##### 레거시 시스템 기준 성능 측정 결과
- 단일 데이터 처리 속도 평균 : 1초
- 1000건 데이터 처리 속도 평균 : 110초

| RECORD_COUNT |  DURATION |
| -----------: | --------: |
|            1 |   1263 ms |
|            2 |   1017 ms |
|         1000 | 114826 ms |
##### 개선 사항
- `LBMS` 가맹점 등록 API 요청을 하기 위한 ApplicationEvent 단건 발행 부분 수정
	- chunk size 만큼의 가맹점 데이터를 다건 Event 발행 처리하도록 수정
###### 개선 결과
- 단일 데이터 처리 속도 평균 : 0.8초
- 1000건 데이터 처리 속도 평균 : 110초

| RECORD_COUNT |  DURATION |
| -----------: | --------: |
|            1 |    848 ms |
|            2 |   1165 ms |
|         1000 | 111279 ms |

----

#### 2차 성능 개선

##### 개선 사항
- `KB_MERCHANT`, `KB_MERCHANT_HISTORY` Entity 정보 신규 등록 & 변경하여 신규 Entity 생성 후 단건 `save` 처리 부분 수정
	- `List<Entity>` 타입으로 `saveAll` 다건 저장 처리하도록 수정
	- 하지만, 성능 측면 큰 차이는 없는 듯.. 😥
- `LBMS` 가맹점 등록 API 비동기 처리
	- 1000건 처리 소요 시간 중 `LBMS` API 요청 처리 소요 시간 30초 가량
	- 비동기 방식으로 API 요청하도록 수정
	- `CompletableFuture` 활용한 비동기 코드 구현
		- `CompletableFuture` 비동기 코드 구현 주의 사항
			- 비동기 코드 런타임 예외에 대한 로그 출력 등 별도 예외 처리 필요
			- Thread Pool 관리 
				- Thread Pool 크기 설정 방식
					- CPU 바운드 작업 : CPU 사용량 큰 작업인 경우, 스레드-풀 크기를 CPU 코어 수와 비슷하게 설정하도록 권장 > `N_CPU + 1`
					- I/O 바운드 작업 : I/O 사용량 큰 작업인 경우, 스레드 대기 시간이 길어지므로 더 많은 스레드 확보가 필요 > `N_CPU * 2` or `N_CPU * 2 + 1`
				- `int nThreads = Runtime.getRuntime().availableProcessors() * 2;` 코드를 통해 스레드-풀 크기 설정
				- Thread Pool 명시적 종료 처리 필요
					```java
					ExecutorService executor = Executors.newFixedThreadPool(nThreads);
					// 비동기 처리
					executor.shutdown();
					```

###### 개선 결과
- 단일 데이터 처리 속도 평균 : 0.9초
- 1000건 데이터 처리 속도 평균 : 70초

| RECORD_COUNT | DURATION |
| -----------: | -------: |
|            1 |   933 ms |
|            2 |  1022 ms |
|         1000 | 68391 ms |

---

#### 3차 개선

##### 개선 사항
- 