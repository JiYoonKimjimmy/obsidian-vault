
----
#### 질문
먼저 구축하려는 시스템에 대해서 설명해줄게. 

시스템은 "가상 순번 대기 솔루션" 이야. 많은 상용 서비스가 있지만, 자사의 요구 사항에 맞는 VWR 솔루션을 개발하려고 해. 
운영하고 있는 앱 서비스에서 HTTP 네트워크 통신 요청하고, 일시적으로 급증하는 대용량 트래픽에 대한 서비스 진입을 제어하기 위해서 VWR 솔루션을 적용하려고 해. 

기능에 대한 요구사항은 다음과 같아. 
1. 분당 허용 트래픽 임계치 설정(언제든지 변경 가능한 설정값) 
2. 클라이언트에서 트래픽 대기 요청 
3. 서버에서 트래픽 대기 요청 순서대로 대기 순번 할당 
4. 트래픽 대기 요청 별 설정된 임계치와 함께 계산하여 대기 예상 시간 계산 
5. 클라이언트는 대기 예상 시간만큼 대기 후 트래픽 진입 요청 
6. 서버에서 현재 설정된 임계치 값 기준 트래픽 진입 가능한지 판단 
	- 트래픽 진입 가능한 경우. 허용 여부 Y 응답
	- 트래픽 진입 불가한 경우, 허용 여부 N & 추가 대기 시간 계산값 응답 
7. 클라이언트는 트래픽 진입 허용 여부 Y 일 때까지, 5 ~ 6번 반복 

위와 같은 프로세스 기준으로 VWR 시스템을 구현하고 싶어. 

시스템 트래픽 규모는 아래와 같을 것 같아. 
- 요청 트래픽 : 100K/min, 1M/hour
- 사용자 수 : 100K

----
#### 질문
트래픽 제어 프로세스에 대해서 좀 더 처리 과정을 상세화하여 구조를 생각해보자.

- 최초 설정 : 분당 허용 트래픽 `2000` 임계치 설정인 경우
	- `1 ~ 2000` 대기 순번 바로 입장 가능
	- `2001 ~ 4000` 대기 순번 `1분` 대기 후 입장 가능
	- `4001 ~ 6000` 대기 순번 `2분` 대기 후 입장 가능
- 중간 설정 : 분당 허용 트래픽 `1000` 임계치 설정 변경인 경우
	- `6001 ~ 7000` 대기 순번 `3분` 대기 후 입장 가능
	- `7001 ~ 8000` 대기 순번 `4분` 대기 후 입장 가능
	- `8001 ~ 9000` 대기 순번 `5분` 대기 후 입장 가능
	- `9001 ~ 10000` 대기 순번 `6분` 대기 후 입장 가능
- 중간 설정 : 분당 허용 트래픽 `500` 임계치 설정 변경인 경우
	- `10001 ~ 10500` 대기 순번 `7분` 대기 후 입장 가능
	- `10501 ~ 11000` 대기 순번 `8분` 대기 후 입장 가능
- 중간 설정 : 분당 허용 트래픽 `1000` 임계치 설정 변경인 경우
	- `11001 ~ 12000` 대기 순번 `9분` 대기 후 입장 가능

위와 같은 방식으로 설정에 따른 대기 순번 별 대기 시간은 달라질 수 있도록 할거야.

그렇다면, 먼저 검토해볼 부분은 현재 시스템 구조에서의 `Queue Manage` 와 `Entry Evaluator` 모듈이 논리적으로도 분리가 필요할까?
대기 순번과 임계치 값 기준으로 대기 예상 시간을 계산하고, 대기 예상 시간 기준으로 진입 여부를 판단하는 로직을 구현한다면 하나의 모듈에서 처리 가능할 것 같은 생각인데 어때?

#### 답변

```bash
[Client App]
   |
   v
[API Gateway]
   |
   v
==================== VWR 단일 서비스 ====================
|                                                      |
|  1. API Layer (Controller)                           |
|     - /join, /entry 같은 endpoint 처리               |
|                                                      |
|  2. Admission Scheduler (← Queue + Entry 통합)       |
|     - 순번 할당                                      |
|     - 입장 가능 시간 계산                            |
|     - 현재 시간 기반 입장 여부 판단                  |
|                                                      |
|  3. Config Manager                                   |
|     - 허용 임계치 변경 관리                          |
|     - 분당 허용량 스냅샷 리스트 유지 (history 기반)  |
|     - 실시간 반영 (pub/sub or polling)               |
========================================================
```

----
#### 질문
좋아 그럼 Redis 를 활용하여 분산 환경에서 적용할 수 있는 토큰 버킷 + 큐 혼합한 방식으로 알고리즘을 정리해보자.

요구 사항으로는 버킷의 리필 속도는 분당 임계치 만큼 고정적이길 원해.

그러니 설정된 임계치가 2000 이라면, 1분 안에 2000개를 모두 소진하거나 1분 안에 2000개를 소진하지 못하더라도 1분 뒤에는 다시 2000개 채워져 있어야하는거지.

먼저 내가 정리한 요구 사항이 맞는지 다시 한번 리뷰해보고 알고리즘을 설명해주길 바래

#### 답변
### ✅ 요구 사항 검토 결과

| 항목    | 요구 사항      | 검토          |
| ----- | ---------- | ----------- |
| 리필 속도 | 고정적, 분당    | ✅ 만족        |
| 리필 정책 | full reset | ✅ 만족        |
| 순서 보장 | 필수         | ✅ 큐 도입으로 가능 |
| 분산 환경 | Redis 사용   | ✅ 적합        |
### 🧠 알고리즘 설계: Redis 기반 Token Bucket + FIFO Queue

#### 📦 사용 Redis 키 구성

| Redis Key            | 설명                                              |
| -------------------- | ----------------------------------------------- |
| `vwr:queue`          | 대기 순서 보장용 FIFO queue (Redis List or Sorted Set) |
| `vwr:bucket_tokens`  | 현재 남아 있는 토큰 수                                   |
| `vwr:last_refill_ts` | 마지막으로 리필한 시각 (Unix timestamp 단위)                |
| `vwr:rate_limit`     | 현재 설정된 분당 임계치 (예: 2000)                         |
#### 🔄 Step 1. 대기 요청 처리 (Join)
1. 유저가 `/join` 요청
2. Redis `INCR`로 유저 ID에 순번 부여
3. `vwr:queue`에 `(timestamp, user_id)` 삽입 (`Sorted Set`)
4. 예상 대기 시간 계산:
    - 현재 큐에서 내 순서 = 몇 번째인지 확인
    - 현재 토큰 상태와 속도 기준으로 **입장 가능 시점 예측**
5. 클라이언트에 대기 순번 + 예상 대기 시간 응답
#### 🔄 Step 2. 진입 요청 처리 (Entry)
1. 유저가 `/entry` 요청
2. **큐의 가장 앞**이 해당 유저인지 확인
    - 아니면 → “아직 너 차례 아님” 응답
3. Token refill 체크:
    - `last_refill_ts` 확인
    - 현재 시각 기준 1분 이상 지났으면 → `rate_limit` 값만큼 토큰 refill
    - `bucket_tokens` 값을 갱신
4. 토큰이 있다면:
    - `bucket_tokens`에서 `DECR`
    - `vwr:queue`에서 해당 유저 제거
    - 입장 허용
5. 토큰이 없다면:
    - 대기 상태 유지
    - 예상 대기 시간 다시 계산하여 응답
#### 🧮 예상 대기 시간 계산 방식 (Entry or Join 시 사용)

```python
# queue_position: 내가 몇 번째인지 (1-based index) 
# rate_per_min: 분당 토큰 생성 수  
wait_minutes = floor(queue_position / rate_per_min) 
# 또는 wait_seconds = (queue_position / rate_per_min) * 60
```
#### 📌 최종 구조 요약

```
[Client]
   |
   | /join
   v
[VWR API 서버]
   |
   |→ Redis ZADD vwr:queue (timestamp, user_id)
   |→ Redis GET vwr:bucket_tokens + refill 처리
   |
   | /entry
   v
(내가 queue 맨 앞인지?)
   |
   |→ 토큰 있으면 입장
   |→ 없으면 대기 시간 계산 후 응답
```

#### ✅ 장점 요약
- 순서 보장 + 속도 제어 완벽 지원
- 분당 임계치 리필 정책 확실히 구현 가능
- Redis 하나로 모든 상태 관리 가능
- Lua 스크립트로 atomic하게 처리 가능
- 예상 대기 시간 계산 가능 (예측형 응답)

----
