
> [Toby Lee](https://www.linkedin.com/in/tobyilee/) 님의  안내서 그대로 정리

![Toby Lee](https://media.licdn.com/dms/image/v2/D4E03AQGrsrwhjhtZTg/profile-displayphoto-shrink_100_100/profile-displayphoto-shrink_100_100/0/1722650634451?e=1753315200&v=beta&t=TfOKe_tlZ2r2BKX711HR9_BkV4QZcGg6apX8sPTA9tc)

## [Toby Lee](https://www.linkedin.com/in/tobyilee/) 

**_Gemini의 Deep Research 기능으로 도메인 모델에 관해 몇 가지 연구와 정리를 요청해봤다._**

# I. 서론: 도메인 모델의 중심성

## A. 도메인 모델 정의: 소프트웨어를 위한 개념적 청사진

소프트웨어 공학에서 **도메인 모델(Domain Model)** 은 특정 지식, 영향력 또는 활동 영역(즉, "도메인")을 나타내는 개념적 모델로, 해당 영역의 데이터와 행위를 모두 포함한다.
이는 단순히 기술적 구현을 위한 설계도가 아니라, 해결하고자 하는 문제 영역 자체에 대한 깊은 이해를 구조화한 결과물이다. 도메인 모델의 핵심 목적은 도메인 전문가들이 사용하는 용어, 개념, 그리고 이들 간의 관계의 의미를 명확히 표현하는 것이다.
초기 단계에서는 동시성이나 데이터 저장 방식과 같은 특정 구현 세부 사항과는 독립적으로, 비즈니스 자체에 대한 이해와 명확성을 확보하는 데 중점을 둔다.

본질적으로 도메인 모델은 해당 도메인과 관련된 의미 있는 실제 세계의 개념들을 표현하며, 여기에는 비즈니스 데이터와 해당 데이터와 관련된 비즈니스 규칙이 포함된다.
이 모델은 도메인의 자연어를 활용하여 구축되므로, 기술적인 지식이 없는 이해관계자들과도 효과적으로 소통할 수 있는 기반을 제공한다. 잘 구축된 도메인 모델은 해당 도메인 내 애플리케이션 개발을 위한 안정적인 토대가 된다.

이러한 도메인 모델은 실제 세계의 문제 영역과 이를 해결하기 위한 소프트웨어 솔루션 사이의 중요한 다리 역할을 한다. 
모델은 문제 영역의 본질적인 복잡성을 포착하고, 이를 소프트웨어 아키텍처와 코드 구조로 변환하는 지침을 제공한다.
결과적으로, 도메인 모델은 소프트웨어가 실제 비즈니스 요구사항을 정확히 반영하고 효과적으로 해결하도록 보장하는 핵심 요소가 된다.

## B. 보고서의 목적과 구조

본 보고서는 소프트웨어 개발에서 도메인 모델이라는 개념이 어떻게 진화해왔는지, 그리고 현대 개발 방식에서 어떻게 이해되고 활용되는지를 포괄적으로 탐색하는 것을 목표로 한다. 먼저, 구조적 분석 및 초기 객체 지향 패러다임과 같은 과거 개발 방법론에서의 도메인 모델 정의와 활용 방식을 살펴본다. 
이어서 도메인 주도 설계(Domain-Driven Design, DDD)와 애자일 방법론으로 대표되는 현대 소프트웨어 개발에서 도메인 모델의 재정의된 역할, 중요성 변화, 그리고 구체적인 활용 방안(예: 유비쿼터스 언어 구축, 바운디드 컨텍스트 정의)을 분석한다.

과거와 현재의 관점에서 도메인 모델링이 제공하는 이점을 비교 분석하고, 이러한 이해를 바탕으로 주니어 개발자들이 도메인 모델의 개념과 중요성을 쉽게 이해하고 실제로 모델을 생성, 문서화, 공유할 수 있도록 구체적이고 실용적인 가이드라인을 제시하며 마무리한다. 
이 보고서는 숙련된 개발자에게는 깊이 있는 통찰을, 경력이 부족한 개발자에게는 명확한 실행 지침을 제공하고자 한다.

# II. 초기 소프트웨어 개발에서의 도메인 모델링: 기반 마련

## A. 추상화의 필요성: 현실을 포착하려는 초기 시도

소프트웨어 개발의 초기부터, 복잡성을 관리하고 코딩에 앞서 요구사항을 이해하고 관리하기 위한 모델의 필요성은 명확히 인식되었다. 복잡한 시스템을 다루기 위해서는 현실 세계의 문제 영역을 추상화하여 표현하는 방법이 필수적이었다. 이러한 요구에 부응하여 등장한 초기 접근법 중 하나가 **도메인 분석(Domain Analysis)** 이다. 
이는 특정 문제 영역이나 유사한 시스템 클래스 내에서 공통적인 특징, 객체, 연산 등을 식별하고, 이를 재사용 가능한 정보로 조직화하는 활동을 의미한다.
네이버스(Neighbors)는 이를 **"특정 문제 영역 내 유사 시스템 클래스의 객체와 연산을 식별하는 활동"** 으로 정의하며, 시스템 분석이 특정 시스템에 초점을 맞추는 반면 도메인 분석은 여러 시스템에 걸친 일반화된 모델을 목표로 한다고 구분했다.

이와 병행하여 **개념 모델(Conceptual Model)** 의 중요성도 부각되었다. 
개념 모델은 이해관계자 간의 모호한 용어 해석으로 인한 혼란을 방지하고 공유된 이해를 구축하기 위한 초기 단계의 산출물로 정의된다.
이는 의도적으로 설계나 구현 세부 사항과 독립적으로 유지되며, 비즈니스 용어집(Lexicon)을 정의하고, 이를 기반으로 시스템 사용 시나리오(Task scenarios/Use cases)를 작성하는 데 활용되었다.

이러한 초기 모델링 노력의 근본적인 동기는 상당한 코딩 투자가 이루어지기 전에 인지 부하를 관리하고 공유된 이해를 확보하려는 필요성에서 비롯되었다. 초기에 발생하는 오해는 개발 후반부에 큰 비용을 초래할 수 있음을 인식했기 때문이다.
즉, 소프트웨어 구축에는 문제에 대한 공유된 정신 모델이 필요하며, 이를 조기에 공식화하는 것이 오류와 재작업을 줄이는 효과적인 방법이라는 공감대가 형성되기 시작했다.

## B. 구조적 시대: 데이터와 흐름의 모델링 (ERD, DFD)

1970년대와 1980년대에 주류를 이루었던 **구조적 분석(Structured Analysis) 방법론** 은 시스템을 주로 프로세스와 데이터 흐름의 관점에서 분석했다. 

이 시기에 도메인의 서로 다른 측면을 모델링하기 위해 두 가지 주요 다이어그램이 널리 사용되었다.

- **데이터 흐름 다이어그램 (Data Flow Diagram, DFD)** 
	- DFD는 시스템 내 정보의 흐름을 시각적으로 표현하는 데 중점을 두었다. 
	- 이는 데이터가 시스템으로 들어오고 나가는 지점(External Entities), 데이터를 변환하거나 처리하는 활동(Processes), 데이터가 저장되는 장소(Data Stores), 그리고 이들 요소 간 데이터의 이동 경로(Data Flows)를 표준화된 기호를 사용하여 나타냈다.
	- DFD는 여러 수준(Level)으로 작성되어 시스템을 점진적으로 상세화할 수 있었다. 최상위 레벨인 컨텍스트 다이어그램(Level 0)은 시스템 전체를 단일 프로세스로 보고 외부와의 상호작용을 보여주며, 하위 레벨로 내려갈수록 각 프로세스가 더 작은 단위로 분해되어 상세한 흐름을 보여준다.
	- DFD는 복잡한 시스템을 이해하기 쉬운 부분으로 나누고, 팀원 간의 의사소통을 개선하며, 프로세스의 비효율성을 발견하는 데 유용하게 사용되었다.
	- 이는 도메인의 _동적_ 측면, 즉 데이터가 어떻게 이동하고 변환되는지를 모델링하는 데 초점을 맞췄다.

- **개체-관계 다이어그램 (Entity-Relationship Diagram, ERD)** 
	- ERD는 시스템이 다루는 데이터의 _정적_ 구조를 모델링하는 데 사용되었다. 
	- 이는 시스템에서 중요한 '사물' 또는 개념(Entities), 이러한 사물의 속성(Attributes), 그리고 사물들 간의 연관성(Relationships)을 표현했다.
	- ERD의 핵심 요소는 명사로 표현되는 개체(예: 고객, 주문), 동사로 표현되는 관계(예: 고객이 주문을 _한다_), 그리고 개체의 특성을 나타내는 속성(예: 고객 이름, 주문 날짜)과 관계의 수치적 특성을 나타내는 카디널리티(Cardinality, 예: 1:N 관계) 등이다.
	- ERD는 주로 데이터베이스 설계를 위한 청사진으로 사용되었으며, 도메인의 정보 구조를 이해하는 데 중요한 역할을 했다.

구조적 분석 기법들은 각각 데이터와 프로세스라는 도메인의 중요한 측면을 포착했지만, 이들을 별개의 모델로 분리하여 표현했다. 
**ERD는 데이터 구조에 집중**하고, **DFD는 데이터 흐름에 집중**했기 때문에, 이 두 모델을 통합하고 일관성을 유지하는 데 어려움이 따를 수 있었다.

이는 이후 등장하는 객체 지향 접근법과 대비되는 지점이다. 객체 지향은 데이터와 그 데이터를 조작하는 행위를 '객체'라는 단일 단위로 묶어 표현함으로써, 도메인 요소에 대한 보다 통합된 시각을 제공하고자 했다.

## C. 객체 지향의 여명: 세상을 객체로 모델링하다

1960년대 Simula 언어의 등장과 함께 시작된 객체 지향(Object-Orientation, OO) 패러다임은 소프트웨어 개발에 근본적인 변화를 가져왔다.21 시스템을 상호작용하는 '객체(Object)'들의 집합으로 바라보는 이 접근법은 현실 세계의 사물이나 개념을 소프트웨어 내에서 직접적으로 모델링하려는 시도였다.4 Simula는 원래 복잡한 시스템 시뮬레이션을 위해 개발되었으며, 이를 위해 현실 세계의 요소를 클래스(Class)와 객체(Object)로 표현하는 개념을 도입했다.22 이후 1970년대 Smalltalk는 이러한 개념을 더욱 발전시켜 완전한 객체 지향 환경과 그래픽 사용자 인터페이스(GUI)를 통합하며 OO 패러다임의 대중화를 이끌었다.8

초기 객체 지향 분석(OOA)은 문제 영역에서 핵심 객체(클래스)를 식별하는 데 중점을 두었다. 이를 위해 요구사항 명세서나 관련 문서에서 명사를 식별하는 기법 등이 활용되었다.16 1990년대에 들어서면서 제임스 럼바(James Rumbaugh) 등이 개발한 **객체 모델링 기법(Object Modeling Technique, OMT)**은 초기 OO 방법론 중 가장 영향력 있는 것 중 하나로 부상했다.26 OMT는 시스템을 세 가지 관점에서 모델링했다 26:

1. **객체 모델(Object Model):** 시스템의 정적 구조를 표현하며, 클래스, 속성, 연산(메서드) 및 클래스 간의 관계(상속, 집합(Aggregation), 연관(Association))를 다이어그램으로 나타낸다. 이는 ERD와 유사하지만, 객체의 행위(연산)를 포함한다는 점에서 차이가 있으며, OMT의 가장 핵심적인 모델로 간주되었다.26
2. **동적 모델(Dynamic Model):** 상태 다이어그램(State Transition Diagram, STD)을 사용하여 객체가 이벤트에 반응하여 상태를 변경하는 방식, 즉 객체의 생명주기와 행위를 모델링한다.26
3. **기능 모델(Functional Model):** 전통적인 데이터 흐름 다이어그램(DFD)을 사용하여 시스템 내 데이터의 변환 과정을 보여준다. 하지만 다른 두 모델과의 통합성이 상대적으로 부족하다는 평가를 받았다.26

OMT의 목표는 시스템에 대한 포괄적인 시각을 제공하고 분석에서 설계 단계로의 전환을 원활하게 하는 것이었다.26 이 시기에는 OMT 외에도 부치(Booch), 코드/요든(Coad/Yourdon), 슐레어/멜러(Shlaer/Mellor) 등 다양한 OO 방법론들이 경쟁적으로 등장했으며, 이는 이후 통합 모델링 언어(Unified Modeling Language, UML)로 통합되는 기반이 되었다.9

초기 객체 지향 모델링의 중요한 특징 중 하나는 **도메인 모델**(주로 객체 모델)을 분석 단계의 핵심 산출물로 간주했다는 점이다. 당시 개발자들은 현실 세계를 반영하는 이 객체 모델을 올바르게 구축하는 것이 성공적인 시스템 설계의 핵심이라고 믿었다.30 심지어 잘 만들어진 객체 모델로부터 시스템 코드의 상당 부분을 자동으로 생성할 수 있을 것이라는 기대도 있었다.30 이러한 관점은 객체 모델 자체가 시스템 아키텍처의 근본적인 청사진 역할을 할 수 있다는 강한 믿음을 반영한다.9

### III. 현대 시대: 도메인 주도 설계(DDD)와 애자일

### A. 복잡성 다루기: 도메인 주도 설계(DDD)의 출현

2003년 에릭 에반스(Eric Evans)가 저술한 책을 통해 널리 알려진 **도메인 주도 설계(Domain-Driven Design, DDD)**는 특히 비즈니스 로직이 복잡한 도메인을 다루기 위한 소프트웨어 개발 접근법이다.3 DDD는 개발의 초점을 애플리케이션의 핵심 도메인과 도메인 로직 계층에 맞추고, 도메인에 대한 깊이 있는 이해를 바탕으로 정교한 모델을 구축하는 것을 강조한다.3

DDD의 핵심 철학은 소프트웨어를 비즈니스 요구사항 및 현실과 긴밀하게 일치시키는 것이다.5 이를 위해 기술 전문가와 도메인 전문가 간의 창의적인 협업이 필수적이며, 이 협업을 통해 특정 도메인 문제를 해결하는 개념 모델을 반복적으로 개선해 나간다.3 DDD는 단순히 기술적인 구현 패턴의 집합이 아니라, 복잡한 문제를 효과적으로 해결하기 위해 도메인 자체에 집중하는 사고방식이자 전략이다.

### B. 재정의된 도메인 모델: 풍부함, 행위, 그리고 유비쿼터스 언어

DDD는 과거의 일부 접근법에서 나타날 수 있는 "빈약한(anemic)" 도메인 모델, 즉 데이터 필드와 getter/setter 메서드만 가지고 실제 비즈니스 로직은 서비스 계층 등 외부에 존재하는 모델을 지양한다.38 대신 DDD는 **풍부한(rich) 도메인 모델**을 추구한다. 이러한 모델에서 객체는 단순히 데이터를 담는 컨테이너가 아니라, 관련된 복잡한 비즈니스 로직과 행위(메서드)를 스스로 캡슐화한다.41

이러한 풍부한 모델을 구축하고 소통하는 데 핵심적인 역할을 하는 것이 **유비쿼터스 언어(Ubiquitous Language, UL)**이다. 이는 도메인 모델에 기반하여 정의된, 프로젝트에 관련된 모든 사람(개발자, 도메인 전문가, 기획자, 테스터 등)이 공유하고 엄격하게 사용하는 단일 언어이다.3 이 언어는 회의, 문서뿐만 아니라 소스 코드(클래스, 메서드, 변수 이름 등)에서도 일관되게 사용되어야 한다.5 UL의 목적은 의사소통의 간극을 메우고, 코드가 도메인을 정확하게 반영하도록 보장하며, 용어의 모호성을 제거하는 것이다.5 예를 들어, 전자상거래 시스템에서 '주문'이라는 개념은 코드와 문서, 대화에서 항상 'Order'라는 용어로 일관되게 지칭되어야 하며, 'Purchase'나 'Transaction' 같은 다른 용어와 혼용되지 않아야 한다.43

또한 DDD는 **모델 주도 설계(Model-Driven Design)** 개념을 강조한다. 이는 모델이 단순히 개발 시작 전의 청사진으로 끝나는 것이 아니라, 개발 과정 중에 코드 자체 내에서 지속적으로 진화하고 개선되어야 한다는 생각이다.5 도메인에 대한 새로운 통찰이나 이해가 생기면, 이를 즉시 코드 상의 모델에 반영하여 모델을 살아있고 정확하게 유지한다. 코드가 모델을 포착하고 표현하는 것이 DDD의 핵심 아이디어 중 하나이다.31

유비쿼터스 언어는 단순한 용어집 이상의 의미를 지닌다. 이는 적극적인 설계 도구로서 기능한다. 팀 내에서 특정 용어나 개념에 대한 합의가 어렵거나 모호함이 발견될 때, 이는 종종 근본적인 도메인 모델 자체의 문제점이나 개선 필요성을 시사한다.43 용어에 대한 논쟁은 해당 도메인 개념에 대한 더 깊은 논의를 촉발하고, 결과적으로 더 명확하고 정제된 모델로 이어진다.3 이름 짓기의 어려움은 종종 책임이나 경계가 불분명하게 정의되었음을 나타내는 신호일 수 있다.

### C. 전략적 설계: 대규모 시스템 길들이기

대규모 엔터프라이즈 시스템에서는 단일한 통합 모델로 전체 비즈니스를 표현하는 것이 비현실적이며 오히려 해가 될 수 있다.3 시스템의 복잡성이 증가함에 따라 모델의 일관성을 유지하기 어렵고, 서로 다른 비즈니스 영역 간의 개념 충돌이 발생할 수 있다. DDD는 이러한 문제를 해결하기 위해 **전략적 설계(Strategic Design)**라는 개념을 제시한다.32 전략적 설계는 거대한 시스템을 관리 가능한 여러 부분으로 나누고 이들 간의 관계를 정의하는 데 중점을 둔다.

전략적 설계의 핵심 개념은 **바운디드 컨텍스트(Bounded Context, BC)**이다. BC는 특정 도메인 모델과 그 모델을 설명하는 유비쿼터스 언어가 일관되게 적용되는 명시적인 경계이다.3 하나의 BC 내에서는 모든 용어와 개념이 명확하고 모호함 없이 정의된다. 하지만 서로 다른 BC에서는 동일한 용어라도 다른 의미나 중요도를 가질 수 있다.48 예를 들어, 전자상거래 시스템에서 '상품(Product)'이라는 개념은 재고 관리 BC와 카탈로그 관리 BC에서 서로 다른 속성과 행위를 가질 수 있다. BC는 이렇게 모델의 유효 범위를 제한함으로써, 각 부분을 독립적으로 개발하고 관리할 수 있게 하여 복잡성을 낮추고 모델의 오염을 방지한다.5 실제 사례로는 전자상거래 시스템의 장바구니(Basket), 재고(Inventory), 결제(Payment) 컨텍스트 50나 은행 시스템의 계좌 관리(Account Management), 대출 처리(Loan Processing) 컨텍스트 32 등이 있다.

BC 간의 관계를 시각화하고 정의하는 도구로는 **컨텍스트 맵(Context Map)**이 사용된다.31 컨텍스트 맵은 각 BC가 서로 어떻게 상호작용하는지(예: 공유 커널(Shared Kernel), 고객-공급자(Customer-Supplier), 순응주의자(Conformist), 충돌 방지 계층(Anti-Corruption Layer, ACL) 등)를 명시적으로 보여주어, 통합 전략을 수립하고 팀 간의 의존성을 관리하는 데 도움을 준다.

전략적 설계, 특히 바운디드 컨텍스트와 컨텍스트 맵핑은 현대적인 마이크로서비스 아키텍처 설계의 핵심적인 기반을 제공한다. 각 BC는 종종 하나 이상의 마이크로서비스로 자연스럽게 매핑될 수 있다.42 BC는 기술적인 측면보다는 도메인의 응집력을 기준으로 서비스 경계를 정의하도록 유도한다. 이는 마이크로서비스의 핵심 원칙인 독립적인 배포, 확장성, 그리고 팀 자율성을 달성하는 데 매우 효과적이다.51 BC를 통해 도메인 로직을 명확하게 분리하고 캡슐화함으로써, 각 마이크로서비스가 특정 비즈니스 능력에 집중하고 독립적으로 발전할 수 있는 구조적 토대를 마련하는 것이다.

### D. 전술적 설계: 바운디드 컨텍스트 내부의 구성 요소

전략적 설계가 시스템 전체를 조망하며 큰 그림을 그리는 것이라면, **전술적 설계(Tactical Design)**는 개별 바운디드 컨텍스트 내부의 모델을 정교하게 구축하는 데 집중한다.32 이는 도메인 모델을 코드 레벨에서 구체화하는 데 사용되는 다양한 빌딩 블록 패턴들을 포함한다.

- **엔티티(Entity):** 속성이 변경되더라도 시간이 지나도 지속되는 고유한 식별성(Identity)을 가진 객체이다.3 예를 들어, 고객(Customer)은 이름이나 주소가 바뀌어도 동일한 고객으로 식별된다. 주문(Order) 역시 고유한 주문 번호로 식별된다.
- **값 객체(Value Object, VO):** 자신을 설명하는 속성들의 값으로 정의되며, 개념적인 식별성을 가지지 않는 객체이다.3 주로 불변(immutable) 객체로 구현되며, 값이 같으면 동일한 것으로 간주된다. 예를 들어, 주소(Address), 금액(Money), 날짜 범위(DateRange) 등이 있다.
- **애그리게잇(Aggregate):** 데이터 일관성을 유지하기 위해 하나의 단위로 취급되는 엔티티와 값 객체들의 묶음(cluster)이다.3 애그리게잇 내에는 하나의 엔티티가 **애그리게잇 루트(Aggregate Root, AR)** 역할을 한다.

- **규칙:** 외부 객체는 오직 애그리게잇 루트만을 참조할 수 있다. 애그리게잇 내부의 상태 변경은 반드시 애그리게잇 루트를 통해서만 이루어져야 한다. 애그리게잇 내의 모든 변경은 하나의 트랜잭션으로 처리되어 일관성이 보장되어야 한다.3 예를 들어, 주문(Order) 애그리게잇은 주문(Order) 엔티티(AR)와 여러 개의 주문 항목(OrderItem) 엔티티로 구성될 수 있다.32

- **리포지토리(Repository):** 애그리게잇의 영속성(persistence) 처리(저장 및 조회)를 위한 추상화 계층이다.3 도메인 계층과 데이터 인프라 계층 사이의 중재자 역할을 하며, 데이터베이스 접근과 같은 영속성 관련 세부 구현을 도메인 모델로부터 숨긴다.55 일반적으로 각 애그리게잇 루트마다 하나의 리포지토리가 존재한다.
- **도메인 이벤트(Domain Event):** 도메인 내에서 발생한 의미 있는 사건을 나타내는 객체이다.3 이를 통해 애그리게잇 간의 상호작용이나 시스템의 부수 효과(side effect)를 느슨하게 결합된(decoupled) 방식으로 처리할 수 있다.51 예를 들어, OrderPlaced 이벤트는 주문이 생성되었음을 알리고, 이를 통해 재고 감소, 사용자 알림 등의 후속 조치를 트리거할 수 있다.
- **팩토리(Factory) & 도메인 서비스(Domain Service):** 복잡한 객체 생성 로직을 캡슐화하거나(팩토리), 특정 엔티티나 값 객체에 속하기 어려운 도메인 로직을 수행하는 역할(도메인 서비스)을 담당한다.3 도메인 서비스는 주로 상태 없이(stateless) 행위만을 제공한다.

이러한 전술적 패턴들은 DDD가 추구하는 "풍부한 도메인 모델" 개념을 구체적으로 실현하는 도구들이다. 비즈니스 로직은 엔티티, 값 객체, 애그리게잇 내부에 위치하며, 애그리게잇 루트 경계에 의해 보호된다.52 리포지토리는 영속성 처리에 대한 무지(persistence ignorance)를 보장하고 54, 도메인 이벤트는 애그리게잇 간의 통신을 깔끔하게 처리하여 51, 도메인 로직이 애플리케이션 계층이나 인프라 계층으로 누수되는 것을 방지한다. 팩토리는 유효한 객체 생성을 보장하고 50, 도메인 서비스는 특정 객체에 속하지 않는 도메인 로직을 처리한다.32 이 모든 요소들이 결합하여 도메인 모델(엔티티, 값 객체, 애그리게잇)이 애플리케이션의 핵심 비즈니스 로직을 담고 보호하는 중심적인 역할을 수행하도록 보장한다.42

### E. 애자일 개발 내에서의 도메인 모델링

DDD의 반복적이고 점진적인 모델 개선 방식은 애자일(Agile) 개발 방법론의 원칙과 잘 부합한다.33 애자일 데이터 모델링 역시 진화적 모델링을 강조하며 62, DDD의 협업 중심 접근 방식은 애자일 팀의 소통과 피드백 문화를 강화할 수 있다.

하지만 현실적으로 애자일 개발 환경에서 도메인 모델링을 적용하는 데에는 몇 가지 어려움이 존재할 수 있다. 애자일은 빠른 기능 제공과 최소 실행 가능 제품(Minimum Viable Product, MVP) 개발에 중점을 두는 경향이 있어, 깊이 있는 도메인 탐색과 모델링에 충분한 시간을 할애하기 어려울 수 있다.47 당장의 기능 구현에 집중하다 보면 장기적인 설계 품질이나 비즈니스 프로세스와의 정합성을 간과하게 될 위험이 있다.47 단순히 코드 리팩토링만으로는 근본적인 설계 문제를 해결하거나 새로운 도메인 개념을 도입하기 어렵다는 지적도 있다.47

따라서 DDD는 복잡한 시스템을 다루는 애자일 팀에게 유용한 도구 세트로 자리매김할 수 있다. DDD는 단순히 설계가 저절로 좋아지기를 기대하는 대신, 의도적으로 설계를 관리하고 발전시키는 프레임워크를 제공한다.47 바운디드 컨텍스트와 유비쿼터스 언어는 팀이 복잡성을 관리하고, 기술 부채를 줄이며, 진화하는 요구사항에 맞춰 일관성 있는 설계를 유지하는 데 도움을 준다.37

애자일 환경에서 DDD를 효과적으로 활용하기 위해서는 단순히 사용자 스토리를 구현하는 것을 넘어, 의도적이고 협력적인 모델링 활동을 개발 프로세스에 통합하는 것이 중요하다. 예를 들어, 이벤트 스토밍(Event Storming)과 같은 워크숍을 통해 유비쿼터스 언어를 발견하고 바운디드 컨텍스트를 식별하며 44, 스프린트 내에서 모델을 탐색하고 정제하는 시간을 확보해야 한다.6 또한, 리팩토링은 단순히 코드를 정리하는 것을 넘어, 진화하는 유비쿼터스 언어와 도메인 모델에 맞춰 코드를 지속적으로 조정하는 활동이 되어야 한다.31 이는 애자일의 빠른 피드백 루프와 DDD의 깊이 있는 모델링을 조화시켜, 변화에 유연하게 대응하면서도 고품질의 설계를 유지하는 길이다.

### IV. 활용 및 이점: 비교 관점

### A. 과거의 도메인 모델 활용 방식

초기 소프트웨어 개발에서 도메인 모델(또는 그 전신인 개념 모델, ERD, DFD 등)은 주로 다음과 같은 목적으로 활용되었다:

- **문제 영역 이해:** 가장 기본적인 역할은 개발팀이 해결해야 할 문제 영역, 즉 도메인을 분석하고 이해하는 것이었다.7 모델은 복잡한 현실 세계를 추상화하여 파악하는 데 도움을 주었다.
- **데이터베이스 설계 입력:** 특히 ERD는 관계형 데이터베이스 스키마를 설계하는 데 직접적인 입력으로 사용되었다.16 개체는 테이블로, 속성은 컬럼으로, 관계는 외래 키 등으로 변환되었다.
- **시스템 구조 및 요구사항 문서화:** 모델 다이어그램은 시스템의 구조와 데이터 요구사항을 문서화하고 이해관계자들과 공유하는 수단으로 사용되었다.10 DFD는 프로세스 흐름을 문서화하는 데 사용되었다.12
- **고수준 시스템 설계 기반:** 초기 OO 방법론의 객체 모델(OMT 등)은 시스템의 고수준 설계를 위한 기반으로 활용되었으나, 분석 모델과 최종 구현 코드 사이에는 종종 상당한 간극이 존재했다.9

### B. 현대(특히 DDD)의 도메인 모델 활용 방식

현대 소프트웨어 개발, 특히 DDD를 채택한 프로젝트에서 도메인 모델은 훨씬 더 중심적이고 능동적인 역할을 수행한다:

- **유비쿼터스 언어(UL) 구동:** 모델은 팀 전체와 코드베이스 전반에 걸쳐 사용될 공유 언어인 UL을 정의하고 이끌어가는 핵심 동력이다.5
- **바운디드 컨텍스트(BC) 정의:** 전략적 설계의 결과물인 BC는 종종 마이크로서비스의 경계를 정의하는 기준으로 활용되어 아키텍처 설계에 직접적인 영향을 미친다.3
- **핵심 비즈니스 로직 구현:** 도메인 모델 내의 애그리게잇(엔티티, 값 객체)은 더 이상 수동적인 데이터 구조가 아니라, 핵심 비즈니스 규칙과 행위를 직접 구현하고 캡슐화하는 주체이다.42
- **리포지토리 설계 가이드:** 애그리게잇 루트를 기준으로 정의되는 리포지토리 인터페이스는 데이터 영속성 처리 방식을 추상화하고 도메인 모델을 보호하는 역할을 한다.54
- **도메인 이벤트 생성:** 모델 내에서 발생하는 중요한 상태 변화는 도메인 이벤트로 발행되어, 시스템 내 다른 부분과의 느슨하게 결합된 상호작용이나 부수 효과 처리를 가능하게 한다.51
- **코드베이스의 중심 조직 원리:** BC 내에서 도메인 모델은 코드 구조와 구성을 이끄는 핵심 원리가 되어, 관련 로직들이 응집력 있게 배치되도록 한다.33

### C. 변치 않는 중요성: 왜 모델링을 하는가?

도메인 모델링의 구체적인 방식과 강조점은 시대에 따라 변화했지만, 그 근본적인 중요성과 이점은 여전히 유효하며 오히려 현대 개발에서 더욱 강조되고 있다:

- **의사소통 개선:** 모델은 기술팀과 비기술팀(도메인 전문가, 현업 사용자 등) 간의 공유된 이해를 촉진하는 강력한 도구이다. 과거에도 개념 모델은 용어 통일과 오해 방지에 기여했고 2, 현재 DDD의 유비쿼터스 언어는 이를 더욱 강화하여 코드 레벨까지 확장했다.4
- **복잡성 관리:** 소프트웨어 개발은 본질적으로 복잡하며, 모델링은 이러한 복잡성을 관리 가능한 수준으로 분해하고 구조화하는 데 필수적이다. 과거 DFD의 계층 구조나 OMT의 다중 모델 12부터 현재 DDD의 바운디드 컨텍스트와 애그리게잇 3에 이르기까지, 모델은 복잡성을 다루는 핵심 전략이다.
- **설계 명확성 및 품질 향상:** 잘 정의된 모델은 더 명확하고, 구조적이며, 유지보수 및 테스트가 용이한 코드로 이어진다. 과거 OMT도 모듈성과 재사용성을 목표로 했고 26, 현재 DDD는 깨끗하고 비즈니스 로직에 집중된 고품질 설계를 명시적으로 추구한다.4
- **비즈니스 정렬:** 소프트웨어는 궁극적으로 비즈니스 문제를 해결하기 위해 존재한다. 도메인 모델링은 개발되는 솔루션이 실제 비즈니스 요구사항, 규칙, 프로세스를 정확히 반영하도록 보장하는 핵심 수단이다. 과거에는 이것이 암묵적인 목표였다면, DDD에서는 명시적인 최우선 목표가 되었다.5
- **위험 및 비용 감소:** 모델링을 통해 설계 초기에 잠재적인 문제점이나 요구사항의 불일치를 발견함으로써, 개발 후반부에 발생할 수 있는 값비싼 수정 작업을 줄일 수 있다.4 또한 유지보수성이 향상되어 장기적인 비용 절감 효과도 있다.
- **유연성 및 확장성:** 특히 DDD의 바운디드 컨텍스트를 통한 모듈화는 시스템의 특정 부분을 독립적으로 수정하거나 확장하기 용이하게 만들어, 변화하는 비즈니스 요구사항에 대한 대응력을 높인다.4

### D. [표] 도메인 모델 측면 비교 - 과거 vs. 현재

![글 내용](https://media.licdn.com/dms/image/v2/D4E12AQG_zGZXetQJKA/article-inline_image-shrink_1000_1488/B4EZZ117eBH0AU-/0/1745733794843?e=1753315200&v=beta&t=622wW9fZkTpZzh-aSiYpM2jXOuhYdGJoIOSpIe8kQro)

이 표는 도메인 모델링이 단순한 분석 도구에서 벗어나, 소프트웨어 설계와 구현의 핵심적인 부분으로 진화했음을 명확히 보여준다. 현대의 도메인 모델은 비즈니스 가치와 직접적으로 연결되며, 코드와 함께 살아 숨 쉬는 유기적인 존재로 변화했다.

### V. 도메인 모델링 이해하기: 주니어 개발자를 위한 가이드

### A. 도메인 모델이란 무엇인가? 쉽게 설명하기

도메인 모델을 처음 접하는 주니어 개발자에게는 다소 추상적으로 느껴질 수 있다. 가장 쉽게 이해하는 방법은 **"소프트웨어가 해결하려는 특정 문제 영역(도메인)의 핵심 지도"**라고 생각하는 것이다.6 예를 들어, 온라인 서점 소프트웨어를 만든다면, '온라인 서점 운영'이라는 세상이 바로 도메인이다. 도메인 모델은 이 세상에 존재하는 중요한 것들, 즉 '책', '고객', '주문', '장바구니' 같은 개념들과 이들 사이의 관계(예: '고객'이 '책'을 '주문'한다), 그리고 이 세계를 지배하는 규칙(예: '장바구니'에 담긴 '책'들의 총액을 계산한다)을 표현한 지도와 같다.1

이 지도는 단순히 그림이 아니라, 그 세상(도메인)에서 사용되는 중요한 **'단어'(명사 - 개념, 개체)**와 **'행동'(동사 - 관계, 동작)**을 담고 있다.16 이 지도를 잘 만들면, 소프트웨어를 만드는 모든 사람들이 같은 그림을 보고 같은 언어로 이야기하며 길을 잃지 않고 목표 지점(소프트웨어 완성)까지 갈 수 있게 도와준다.

### B. 왜 주니어 개발자에게 중요할까?

도메인 모델링이 시니어 아키텍트나 하는 어려운 일처럼 보일 수 있지만, 주니어 개발자에게도 매우 중요하다. 그 이유는 다음과 같다:

- **더 나은 코드 작성:** 도메인 모델을 이해하면 비즈니스 문제의 맥락에 맞는 코드를 작성하게 된다. 단순히 기술적인 기능을 나열하는 것이 아니라, '고객이 주문을 생성한다'와 같이 비즈니스 의미가 명확한 코드를 만들 수 있다. 이런 코드는 다른 사람이 이해하기 쉽고, 나중에 수정하거나 기능을 추가하기도 훨씬 수월하다.4 기술 용어 뒤에 숨겨진 비즈니스 의미를 파악하는 데 도움이 된다.
- **쉬운 협업:** 개발팀 동료, 시니어 개발자, 테스터, 심지어 비즈니스 담당자들과 이야기할 때 공통된 언어(유비쿼터스 언어)를 사용할 수 있게 된다.4 "그거 있잖아요, 사용자가 물건 살 때 누르는 거..." 대신 "장바구니(Cart)에 상품(Product)을 추가하는 기능"처럼 명확하게 소통할 수 있어 오해를 줄이고 협업 효율을 높인다.
- **"왜?"에 대한 이해:** 단순히 '어떻게' 코드를 짜는지를 넘어, '왜' 이 기능을 만드는지를 이해하게 된다. 내가 작성하는 코드가 어떤 비즈니스 가치를 창출하는지 연결할 수 있게 되어 업무의 의미를 찾고 동기 부여에도 도움이 된다.36
- **실수 줄이기:** 개발 초기에 모델링을 통해 비즈니스 요구사항에 대한 이해를 명확히 하면, 나중에 잘못된 방향으로 개발하여 시간과 노력을 낭비하는 일을 줄일 수 있다.4 오해를 일찍 발견하고 바로잡는 것이 훨씬 효율적이다.

### C. 첫 도메인 모델 만들기: 실전 연습

복잡하게 생각할 필요 없다. 다음 단계를 따라 간단한 도메인 모델을 만들어 보자:

- **1단계: 듣고 배우기:** 가장 중요한 첫걸음은 문제 영역(도메인)을 이해하는 것이다. 가능하다면 해당 분야 전문가(현업 담당자 등)나 시니어 개발자와 이야기하고, 주어진 요구사항 문서를 꼼꼼히 읽어보자. 목표는 그들이 사용하는 용어와 주요 업무 처리 과정을 파악하는 것이다.6
- **2단계: 중요한 '것'들 찾기 (개념 식별):** 대화나 문서에서 반복적으로 등장하는 중요한 명사나 명사구를 찾아 목록으로 만든다.16 이것들이 모델의 핵심 요소가 될 가능성이 높다. 예를 들어, '고객(Customer)', '상품(Product)', '주문(Order)' 등이 있다. 이들은 고유한 식별자를 가지는 엔티티(Entity)이거나, 무언가를 설명하는 값 객체(Value Object)일 수 있다 (예: '주소(Address)', '가격(Price)').4
- **3단계: '연결 고리' 찾기 (관계 정의):** 찾아낸 '것'들 사이에 어떤 관계가 있는지 나타내는 동사나 구문을 찾는다.4 예를 들어, "고객이 주문을 _한다_", "주문에 상품이 _포함된다_" 와 같은 표현이다. 이때, 관계의 수(카디널리티)도 함께 파악하면 좋다 (예: 한 명의 고객은 여러 개의 주문을 할 수 있다 - 1:N 관계).16
- **4단계: '것'들 설명하기 (속성 및 기본 행위 명시):** 각 개념(엔티티, 값 객체)이 어떤 중요한 정보(속성)를 가지고 있는지 나열한다.4 예를 들어, 고객은 '이름', '이메일'을 가지고, 주문은 '주문 날짜', '총 금액'을 가진다. 또한 각 개념과 관련된 기본적인 행동(메서드)은 무엇인지 생각해본다 (예: 주문은 '총 금액을 계산할 수 있다').1 처음에는 너무 자세하지 않아도 된다.
- **5단계: 그려보기 (시각화):** 파악한 내용을 간단한 다이어그램으로 그려본다. 기본적인 UML 클래스 다이어그램 형식이 가장 흔하게 사용된다.1 각 개념은 사각형 상자로 표현하고, 상자 안에 속성 목록을 적는다. 개념들 사이의 관계는 선으로 연결한다. 복잡한 UML 기호보다는 명확성에 초점을 맞추자.38 종이와 펜, 혹은 화이트보드로 시작해도 충분하다.41
- **6단계: 이야기하고 다듬기 (반복):** 완성된 스케치나 이해한 내용을 팀 동료나 전문가와 공유하고 피드백을 받는다.6 모델을 보면서 질문하고, 이해가 맞는지 확인하는 과정을 거친다. 모델링은 한 번에 끝나지 않는다. 계속해서 다듬고 개선해나가는 반복적인 과정이다.6

### D. DDD 핵심 아이디어 (주니어 눈높이)

DDD에는 여러 개념이 있지만, 주니어 개발자가 꼭 알아두면 좋은 핵심 아이디어 세 가지는 다음과 같다:

- **유비쿼터스 언어 (Ubiquitous Language):** 비즈니스 전문가들이 사용하는 **바로 그 단어**를 코드에서도 똑같이 사용하는 것이 매우 중요하다.31 클래스 이름, 변수 이름, 메서드 이름을 지을 때 항상 "현업에서는 이 개념을 뭐라고 부르지?"라고 자문해보자. 필요하다면 팀 전체가 공유하는 용어집(Glossary)을 만드는 것도 좋은 방법이다.10
- **바운디드 컨텍스트 (Bounded Context):** 하나의 큰 회사에서도 영업 부서와 물류 부서가 '상품'이라는 단어를 조금 다른 의미로 사용할 수 있다.31 이처럼 특정 모델과 언어가 유효한 '경계'가 바로 바운디드 컨텍스트다. 내가 작성하는 코드가 어떤 컨텍스트(경계) 안에서 작동하는지 이해하는 것이 중요하다. 컨텍스트를 벗어나면 모델의 의미가 달라지거나 유효하지 않을 수 있다.
- **애그리게잇 (Aggregate):** '일관성 보호막'이라고 생각하면 이해하기 쉽다. 항상 함께 변경되고 일관성을 유지해야 하는 객체들(예: 주문과 주문 항목들)을 하나의 묶음(애그리게잇)으로 취급한다.3 이 보호막 안의 내용을 변경하려면 반드시 대장 객체(애그리게잇 루트, 예: 주문 객체)를 통해서만 접근해야 한다. 이렇게 하면 데이터가 깨지거나 규칙이 어긋나는 것을 방지할 수 있다.

### E. 모델을 유용하게 만들기: 문서화와 공유

열심히 만든 모델이 서랍 속에서 잠자게 두어서는 안 된다. 모델을 효과적으로 활용하기 위한 몇 가지 방법은 다음과 같다:

- **시각적 다이어그램:** 모델을 표현하는 다이어그램은 가장 중요한 개념과 관계에 초점을 맞춰 간결하고 명확하게 유지한다.41 기본적인 UML 클래스 다이어그램과 같은 표준 표기법을 사용하면 다른 사람들이 이해하기 쉽다.1 Miro, Lucidchart, PlantUML과 같은 도구들이 도움이 될 수 있다.15
- **용어집 (Glossary):** 유비쿼터스 언어의 핵심 용어들을 정의하는 간단한 문서를 유지 관리한다.10 이는 팀 내 의사소통의 기준점이 된다.
- **코드 자체가 문서:** 가장 좋은 문서는 모델과 유비쿼터스 언어를 명확하게 반영하는 코드 자체이다.31 의미 있는 클래스, 메서드, 변수 이름을 사용하는 것이 매우 중요하다.
- **적극적인 소통:** 팀 회의, 기능 계획 논의, 코드 리뷰 시 모델을 적극적으로 활용하여 설명하고 토론한다.4 모델은 살아있는 소통 도구가 되어야 한다.

### F. [표] 주니어를 위한 간단한 도메인 모델 체크리스트

  

![글 내용](https://media.licdn.com/dms/image/v2/D4E12AQEHO-ZflzS_Tg/article-inline_image-shrink_1500_2232/B4EZZ12EhUHkAU-/0/1745733831834?e=1753315200&v=beta&t=PW-o3UOIsfHvsIk5qccQSsMJJwT7HFOSB5fYhuylSyY)

이 체크리스트는 도메인 모델링을 처음 시작할 때 스스로 점검하고 중요한 측면을 놓치지 않도록 도와줄 것이다.

### VI. 결론: 진화하면서도 변치 않는 도메인 모델링의 가치

### A. 여정의 요약: 정적 청사진에서 살아있는 모델로

본 보고서를 통해 살펴본 바와 같이, 소프트웨어 개발에서 도메인 모델의 개념과 활용 방식은 상당한 진화를 거듭해왔다. 초기 구조적 분석 시대의 분리된 데이터 모델(ERD)과 프로세스 모델(DFD), 그리고 초기 객체 지향 시대의 분석 중심 객체 모델(OMT 등)은 주로 시스템을 이해하고 문서화하며 설계를 위한 초기 청사진 역할을 수행했다.

그러나 도메인 주도 설계(DDD)의 등장과 함께 도메인 모델은 훨씬 더 능동적이고 중심적인 역할로 격상되었다. 현대의 도메인 모델은 단순히 정적인 구조를 넘어 비즈니스 행위와 규칙을 풍부하게 담아내며, 유비쿼터스 언어를 통해 팀 전체의 소통과 코드 구현을 이끌어간다. 바운디드 컨텍스트와 같은 전략적 설계 개념은 대규모 시스템의 복잡성을 관리하는 핵심 도구가 되었고, 애그리게잇, 리포지토리, 도메인 이벤트 등의 전술적 패턴은 모델의 비즈니스 로직 표현력과 코드 품질을 향상시켰다. 이제 도메인 모델은 개발 초기 단계의 산출물에 머무르지 않고, 코드와 함께 진화하며 소프트웨어의 생명주기 전반에 걸쳐 살아 숨 쉬는 핵심 요소가 되었다.

### B. 고품질 소프트웨어의 초석으로서의 도메인 모델

이러한 진화에도 불구하고, 혹은 진화를 통해 더욱 강화된 것은 도메인 모델링이 제공하는 근본적인 가치이다. 잘 만들어진 도메인 모델은 다음과 같은 이유로 고품질 소프트웨어 개발의 초석이 된다:

- **향상된 의사소통:** 기술팀과 비즈니스 이해관계자 간의 명확하고 효과적인 소통을 가능하게 한다.4
- **비즈니스 요구사항과의 긴밀한 정렬:** 소프트웨어가 실제 비즈니스 문제와 규칙을 정확하게 반영하도록 보장한다.5
- **복잡성 관리:** 복잡한 문제를 이해하기 쉽고 관리 가능한 단위로 분해하여 다룰 수 있게 한다.3
- **유지보수성 및 유연성 증대:** 잘 구조화된 모델은 코드 변경 및 확장을 용이하게 하여 장기적인 유지보수 비용을 절감하고 변화에 대한 적응력을 높인다.4
- **전반적인 소프트웨어 품질 향상:** 명확한 설계, 높은 응집도, 낮은 결합도를 통해 더 견고하고 신뢰할 수 있는 소프트웨어를 만드는 데 기여한다.4

### C. 지속적인 학습과 협업에 대한 제언

도메인 모델링, 특히 DDD에서 제시하는 깊이 있는 접근 방식은 단번에 습득할 수 있는 기술이 아니다. 이는 개발자와 도메인 전문가 간의 지속적인 대화와 협업을 통해 점진적으로 발전시켜 나가야 하는 과정이다.5

따라서 모든 수준의 개발자는 자신이 참여하는 프로젝트의 도메인을 이해하는 데 시간과 노력을 투자하는 것이 중요하다. 유비쿼터스 언어를 적극적으로 사용하고, 모델에 대해 끊임없이 질문하며, 동료 및 전문가와 협력하여 모델을 개선해 나가려는 자세가 필요하다. 도메인에 대한 깊은 이해와 이를 효과적으로 모델링하는 능력은 기술적 숙련도만큼이나 성공적인 소프트웨어 개발에 필수적인 역량임을 인식해야 할 것이다.