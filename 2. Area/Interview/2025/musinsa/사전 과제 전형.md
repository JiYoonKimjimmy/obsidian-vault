
- ERD 설계 리뷰
	- `PointAccumulation`
	- `PointUsage`
	- `PointUsageDetail`
	- `PointCancellation`
	- `PointConfig`
	- `MemberPointBalance`
- 프로젝트 구조 설계 리뷰
	- 헥사고날 아키텍처
		- `presentation`
		- `application`
		- `domain`
		- `infrastructure`
- 비즈니스 로직 설계 리뷰
	- `UUID` 생성 기능 리뷰
	- 동시성 제어 기능 리뷰
	- 비동기 처리 기능 리뷰
	- **추가 사항 검토 필요..**
- 기술 스펙 리뷰
	- `Java 21`
	- `Kotlin 1.9.25`
	- `Spring Boot 3.5.7`
	- `Spring Data JPA`
		- `Spring JDBC` 전환 검토
		- `Exposed`, `Kotlin JDSL` 등 다른 라이브러리 전환 검토
	- `Kotest`
- 인프라 설계 리뷰
	- `AWS` 인프라 설계
- 바이브 코딩 리뷰
- 아쉬운 점
	- 분산락 미적용
	- Outbox 패턴 미적용
	- 비동기 & 병렬 처리 미적용

---

## ERD 설계 리뷰

### ERD 설계 원칙
- 서비스 내 도메인 별 비즈니스 로직에 따른 명확한 **책임 분리**와 **생명 주기 관리**를 위한 설계
- `PointAccumulation`, `PointUsage` 에서는 다른 책임과 생명 주기를 가지고 있음
- 하나의 통합 포인트 거래 엔티티로 설계하는 경우, 비즈니스 로직 별로 다른 책임과 생명 주기 때문에 다음과 같은 단점 발생
	- `NULL` 값을 저장해야하는 컬럼 수 증가
	- 각 비즈니스 로직 별 포인트 내역 조회 쿼리의 조건 복잡도 증가

#### 책임 & 생명 주기 차이 관점
##### `PointAccumulation` 포인트 적립
- **책임**: 포인트 적립에 대한 출처와 만료일 관리
- **생명 주기**: 적립 > 사용 > 만료/취소
##### `PointUsage` 포인트 사용
- **책임**: 주문 단위 포인트 사용 내역 관리
- **생명 주기**: 사용 > 부분/전체 취소

#### 비즈니스 로직 차이 관점
##### 적립 취소
- **요구 사항**: 사용된 금액이 있는 경우, 적립 취소 불가
- **적립 건 단위로** 취소 처리 필요
##### 사용 취소
- **요구 사항**: 부분 취소 가능
- **주문 단위로** 취소 처리 필요

#### 주요 개발 요구 사항 관점
##### 1원 단위 포인트 사용 추적 관리
- **요구 사항**: "특정 시점에 적립된 포인트는 1원단위까지 어떤 주문에서 사용되었는지 추적할수 있어야 한다."
- `PointUsageDetail` 엔티티 활용하여 포인트 사용에 대한 상세한 내역 추적 관리 가능
##### 사용 취소 시 만료 포인트 처리
- **요구 사항**: "사용취소 시점에 이미 만료된 포인트를 사용취소 해야 한다면 그 금액만큼 신규적립 처리 한다."
- `PointUsageDetail` 에서 사용된 `PointUsage` 별로 사용한 포인트를 확인하고, 각 포인트 별로 `PointAccumulation` 내역에서 잔액 복원 또는 새로운 `PointAccumulation` 생성 처리
```
사용 취소 시나리오:
1. PointUsage.cancel() 호출
2. PointUsageDetail 조회 (어떤 적립에서 사용했는지)
3. 각 PointAccumulation 확인:
   - 만료되지 않음 → availableAmount 복원
   - 만료됨 → 신규 PointAccumulation 생성
```
- 하나의 엔티티로 관리한다면, 다음과 같은 문제점 발생
	- 만료 여부 확인과 신규 적립 처리가 한 엔티티 내에서 복잡도 증가
	- 적립과 사용의 상태가 섞여 로직이 복잡도 증가(**단일 책임 원칙 위반**)

---

## 프로젝트 설계 리뷰

### 헥사고날 아키텍처 적용
- 헥사고날 아키텍처는 핵심 비즈니스 로직을 외부 요소와 분리하여 설계하는 방식
- 핵심 비즈니스 로직은 외부 기술이나 구현 변화에 영향을 받지 않고 유지 보수성, 확장성, 테스트 용이성을 높이는 목표
- 단순히 3-Tier Layered 아키텍처에 반해 계층 간의 책임이 명확하게 분리될 수 있고, 기술에 대한 의존성도 계층간의 분리가 명확해질 수 있다.
- 잘 설계된 아키텍처는 프로그램이 점점 성장할 수록 추가하거나 수정해야하는 코드의 위치도 분명해질 수 있다.

