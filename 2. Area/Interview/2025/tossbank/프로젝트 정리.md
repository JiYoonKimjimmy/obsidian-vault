## 회원 약관 목록 조회 개선
- 서비스 모니터링을 통한 장애 서비스 개선 사항 정리
- 장애 원인 분석
- 설계
- 구현
- 테스트
- 성과
- 예상 질문
### 장애 서비스 개선 사항
- 매월 1일 플랫폼 Core 시스템 대규모 트래픽 인입으로 인한 DB 지연 발생
- 플랫폼 내 서비스 이용 약관 목록 조회 Query 성능 이슈 발견
	- 앱 실행 시 각 서비스 별 회원 약관 동의 목록 조회하면서 목록 조회 Query 다발적으로 실행
### 장애 원인 분석
- 서비스 이용 약관 컨텐츠 버전, 시행 일자 등 복잡한 Query 구조
- 쿼리 내 테이블 간 조건을 조인이 아닌 서브-쿼리로 작성하면서 성능 이슈 발생
- 쿼리 분석 후 튜닝을 통해 개선할 수 있지만, 약관 목록 조회 서비스 특성 상 해당 쿼리는 약관 개정을 통한 변경하기 전에는 결과가 바뀌지 않을 쿼리로 확인
### 설계
- 회원 약관 목록 조회 API 처리 로직 중 해당 쿼리 결과를 캐싱 처리 (Look Aside 패턴)
- 약관 등록/수정/삭제 등 약관 변경 서비스 요청 시 해당 서비스의 쿼리 결과 삭제 처리
- 멀티 인스턴스 환경에서의 데이터 원자성 보장을 위한 Redis 캐시 활용
### 구현
- 회원 약관 목록 조회 함수 `@Cachable` 애노테이션으로 서비스ID 별 약관 목록 조회 결과 TTL 1일 캐싱 처리
	- 캐싱 처리를 통해 해당 쿼리 1일 1회 호출하여 DB 부하 분산 처리
- 약관 목록 조회 결과 삭제 시, Custom Annotation 을 통해 기존 코드 수정 없이 캐시 삭제 처리
	- `@CacheEvict` 애노테이션은 함수의 파라미터 기반으로 캐시 Key 생성하여 캐시 데이터 삭제
	- 하지만, 기존 코드 함수 특성 상 DTO 클래스 내에 있는 파라미터 활용 제한
	- 많은 코드에서 각각 함수 호출하는 부분이 많기 때문에 기존 코드 수정하기 보다 Custom Annotation 활용 결정
	- DTO 클래스에서 캐시 Key 데이터인 서비스ID 추출하여 캐시 Key 생성하여 데이터 삭제 처리
- 그외 추가 이슈: `RedisCommandTimeout` 에러 발생
	- 서비스 부하로 인해 DB 뿐만 아니라 Redis 에서도 지연 발생하여 command-timeout 설정 500ms 초과 인한 `RedisCommandTimeout` 에러 확인
	- 1차적으로 command-timeout 설정을 500ms > 2000ms 으로 조절
	- 2차적으로 Custom CacheErrorHandler 구현으로 `RedisCommandTimeout` 발생 시, DB 처리하도록 개선
		- Redis 쓰기 명령어인 경우, 데이터 원자성 보장을 위해 에러 응답 처리
		- Redis 읽기 명령어인 경우, 예외 무시하고 DB 조회 진행 후 응답 처리
### 테스트
- `RedisCacheManager` Mock 객체를 통해서 `RedisCommandTimeout` 예외 처리
- 테스트 코드 검증 확인
### 성과
- 트래픽 폭증 시 최대 응답시간 **60s** → **1s /** 평균 **500ms** 이하로 개선
- **Redis** 장애 발생 시에도 서비스 중단 없이 안정적 응답 제공

---

## 가맹점 연동 Batch 시스템 성능 최적화

- 서비스 모니터링을 통한 개선 사항
- 지연 원인 분석
- 해결 방안 설계
- 구현
- 테스트
- 성과
### 서비스 개선 사항
- 카드 매입사 가맹점 연동을 위한 가맹점 연동 Batch 시스템 성능 이슈 확인
	- 1K(1000건) 처리: 1분 가량 소요
	- 10K(10000건) 처리: 70분 가량 소요
	- 최대 6M(600만건) 처리: 2~3일 소요
- 최대 6M 가맹점 연동 처리는 상반기/하반기 시작 전 1회 대용량 데이터 연동 요청
### 원인 분석
- Spring Batch 프로세스 기반으로 전문 파일 읽어 데이터 Sync & Blocking 방식으로 처리
	1. 가맹점ID 기준 신규 등록 or 기존 데이터 조회하여 변경 정보 업데이트
	2. 가맹점 주소 기반 좌표 정보 조회
	3. 가맹점 정보 DB 저장
	4. 가맹점 정보 변경 Event API 요청
- 각 프로세스 별로 동기적으로 실행하면서 데이터 처리 병목 현상 발생
	- 특히 가맹점 정보 변경 Event API 가 동기식으로 요청 후 응답을 받으면서 지연 발생
### 설계
- 기존 코드 수정 없이 데이터 처리율을 높이기 위해 Spring Batch Partitioner 적용
- 불필요한 동기식 처리 프로세스 비동기식으로 변경
### 구현
- Spring Batch Partitioner 를 통해 Batch 프로세스 병렬 처리
	- 데이터 크기 10K 이상인 경우 가용-스레드 2/3 할당하여 병렬 처리
	- 병렬 처리 스레드 개수 기준 데이터 파티션 크기 결정
	- 각 파티션 Chunk 단위로 데이터 처리 진행
- 가맹점 데이터 처리 프로세스 중 `가맹점 정보 변경 Event API` 요청을 비동기식으로 변경
	- 해당 API 응답에 대한 후속 처리가 필요 없기 때문에, 비동기적으로 호출 후 Task 종료
### 테스트
- TaskExecutor 가용-스레드 수 직접 설정하면서 스레드-수 별로 처리 소요 시간 확인
- 데이터 연동 건수 별 처리 소요 시간 확인
### 성과
- 테스트 데이터 **10K** 처리 기준
	- 기존 시스템: **약 4300초(70분) 가량**
	- 개선 시스템: **약 24초 (Thread-Pool: 12 기준)**
- 가용-스레드 동적 관리를 통해 시스템 리소스 효율적 사용 및 운영 안정성 확보

---

## 주소정보누리집 시스템 자동화

- 개선 사항 정리
- 설계
- 구현
- 테스트
- 성과
### 개선 사항
- 주소정보누리집 일변동 데이터 수집 자동화
	- 카드매입사 가맹점 연동 시 주소 기반 주소정보누리집의 좌표 정보 조회하여 가맹점 좌표 데이터로 저장
	- 주소정보누리집 데이터 수동 수집하여 DB 저장하기 때문에 최신 좌표 정보 수집 어려움
- 비정형 검색 조건인 주소 데이터 검색 최적화를 위한 `Elasticsearch` 기반 데이터 저장
### 설계
- 주소정보누리집 일변동 파일 다운로드 API 를 1일 Batch 를 통해 수집 자동화
- Spring Batch 를 활용하여 1일 1회 일변동 파일 다운로드
- File-beat > Logstash > Elasticsearch 순서대로 파일 다운로드 후 ES 데이터 적재 자동화
- 주소정보누리집 일변동 데이터 Logstash 를 통해서 ES 인덱스 기준 데이터 가공 처리
- 일변동 도로명/지번 일변동 데이터 주소 검색 최적화를 위한 자체 분석 및 Custom 애널라이저 구성
### 테스트
- 최초 1회 주소정보누리집 데이터 전체 다운로드 후 ES 저장
- 기존 가맹점 데이터 백업하여 테스트 데이터 생성
- 기존 가맹점 주소 데이터 기준 ES 인덱스 주소 좌표 데이터 조회율 확인
### 성과
- 도로명 주소 검색 성공율 : **89.2% > 99.8%**
- 지번 주소 검색 성공율 : **73.3% > 81.3%**
- 평균 1회 주소 검색 소요 시간 : **18ms > 6ms**

---
## 트래픽 제어 서비스 신규 개발

- 프로젝트 개발 배경
- 프로젝트 기능 설계
- 프로젝트 기술 스펙
- 프로젝트 상세 설계
- 프로젝트 성과

