현재 캠페인 프로모션 대량 처리를 위해서 @src/main/kotlin/com/musinsapayments/prepay/application/prepay/admin/campaign/infrastructure/kafka/listener/CampaignPointPromotionListener.kt, @src/main/kotlin/com/musinsapayments/prepay/application/prepay/admin/campaign/infrastructure/kafka/listener/CampaignVoucherPromotionListener.kt 등 카프카 리스너에서 메시지를 받아서 처리를 하고 있어.

근데 카파카에서 메시지를 1건씩 꺼내어 처리를 하는 과정에서 동기 방식으로 처리하다보니 성능이 너무 느린 상황이야. 그래서 성능 개선을 위한 아키텍처로 Queuing 아키텍처를 적용하고 싶어.

Queuing 아키텍처의 Queue 구현체로는 Redis Stream 을 활용하고자 싶어.

Redis Stream 기반으로 Queue 를 구현하면, 내부적으로 Stream Consumer 스레드를 n 개를 생성하여 수신하는거야. 그러면서 Consumer 를 병렬로 처리를 하여 성능 향승을 목표로 하는거지.

큐잉 아키텍처에 대한 설계를 시작해보자.

---

추가 기능 요구 사항을 정리해줄게.

카프카 리스너에서 레디스 스트림에 데이터를 적재한 후에는, 해당 레디스 스트림을 수신하는 컨슈머를 동적으로 스레드 생성하여 처리하도록 구현해야 해.

카프카 리스너 > 레디스 스트림 생성 > 레디스 스트림 데이터 저장 > 레디스 스트림 컨슈머 n 개 생성

근데 중요한 점은 레디스 스트림 컨슈머가 `campaign_promotions.total_count` 데이터 기준으로 동적으로 생성되어야 해.